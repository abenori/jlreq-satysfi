@require: base/length

module JLReqLib : sig
  val string-to-int : string -> int option
  val set-margin : context -> bool -> bool -> length -> length -> block-boxes -> block-boxes
end = struct
  let-rec string-to-int s =
    let len = string-length s in
    if len == 0 then Some(0) else
      let last-char = string-sub s (len - 1) 1 in
      let n = 
        match last-char with
        |`0` -> Some(0)
        |`1` -> Some(1)
        |`2` -> Some(2)
        |`3` -> Some(3)
        |`4` -> Some(4)
        |`5` -> Some(5)
        |`6` -> Some(6)
        |`7` -> Some(7)
        |`8` -> Some(8)
        |`9` -> Some(9)
        |_ -> None
      in
      match n with 
      |None -> None
      |Some(m) ->
        let k = string-to-int (string-sub s 0 (len - 1)) in
        match k with
        |None -> None
        |Some(l) -> Some(10 * l + m)

  let set-margin ctx before-breakable after-breakable before-margin after-margin inner =
    let large-skip = 1000000pt in
    let inline-bb = inline-graphics 10pt 10pt 10pt (fun pt -> []) in
    let dummy-txt = line-break false false (set-paragraph-margin 0pt 0pt ctx) (inline-bb ++ inline-fil) in
    let dummy-len = get-natural-length (dummy-txt +++ dummy-txt) in
    (line-break before-breakable false (set-paragraph-margin before-margin large-skip ctx) (inline-bb ++ inline-fil)) +++
    (block-skip (0pt -' (large-skip *' 2.0) -' dummy-len)) +++
    (line-break false false (set-paragraph-margin 0pt large-skip ctx) (inline-bb ++ inline-fil)) +++
    inner +++
    (line-break false false (set-paragraph-margin large-skip 0pt ctx) (inline-bb ++ inline-fil)) +++
    (block-skip (0pt -' (large-skip *' 2.0) -' dummy-len)) +++
    (line-break false after-breakable (set-paragraph-margin large-skip after-margin ctx) (inline-bb ++ inline-fil))


end

