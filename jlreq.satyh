% -*- coding: utf-8 -*-
@require: option
@require: list
@require: math
@import: lib
@import: base
@import: font
@import: heading
@import: footnote
@import: pagestyle
@import: toc
@import: theorem

type kihon-hanmen-horizontal = 
  | HorizontalAuto
  | HorizontalCenter of jlreq-length
  | Gutter of (|
      line-length : jlreq-length;
      gutter : jlreq-length;
   |)
  | GutterFore-edge of (|
      gutter : jlreq-length;
      fore-edge : jlreq-length;
    |)

type kihon-hanmen-vertical =
   | VerticalAuto
   | VerticalCenter of jlreq-length
   | Top of (|
       block-length : jlreq-length;
       top-space : jlreq-length;
     |)
   | TopBottom of (|
       top-space : jlreq-length;
       bottom-space : jlreq-length;
     |)

type config-cjkfont =
  | CJKFont-preset-ipaex of float
  | CJKFont of (|
    mincho : string * float * float;
    gothic : string * float * float;
  |)

type config-latinfont = 
  | LatinFont-preset-lmodern of float
  | LatinFont of (|
    roman : string * float * float;
    italic : string * float * float;
    sans : string * float * float;
  |)

type config-document = (|
  two-side : bool;
  paper-size : page;
  horizontal-layout : kihon-hanmen-horizontal;
  vertical-layout : kihon-hanmen-vertical;
  header-sep : jlreq-length;
  header-height : jlreq-length;
  line-gap : length;
  font-size : length;
  cjk-font : config-cjkfont;
  latin-font : config-latinfont;
  column : int;
  column-gap : jlreq-length;
|)

module JLReq : sig
  val default-config-document : config-document
  val default-config-part : jlreq-block-heading-config
  val default-config-section : jlreq-block-heading-config
  val default-config-subsection : jlreq-block-heading-config
  val default-config-paragraph : jlreq-run-in-heading-config
  

  val document : (|
      title : inline-text;
      author : inline-text;
      date : inline-text;
      show-toc : bool;
      show-title : bool;
    |) -> config-document ?-> (|
      maketitle : context -> inline-text -> inline-text -> inline-text -> block-boxes;
      table-of-contents : context -> block-boxes -> block-boxes;
    |) ?-> block-text ?-> block-text -> document
  val default-format : (|
    maketitle : context -> inline-text -> inline-text -> inline-text -> block-boxes;
    table-of-contents : context -> block-boxes -> block-boxes;
  |)
  val \hspace : [jlreq-length] inline-cmd
  val float-scheme : (|
    caption-font : nfss;
    caption-label-font : nfss;
    caption-after-label-space : jlreq-length;
    caption-label-format : int -> inline-text;
  |) -> int ref -> context -> string ?-> inline-text -> block-text -> inline-boxes
  
  direct +p : [inline-text] block-cmd
  direct +pn : [inline-text] block-cmd
  direct +part : [string?; inline-text?; inline-text?; inline-text; block-text] block-cmd
  direct +section : [string?; inline-text?; inline-text?; inline-text; block-text] block-cmd
  direct +subsection : [string?; inline-text?; inline-text?; inline-text; block-text] block-cmd
  direct +paragraph : [string?; inline-text?; inline-text; inline-text] block-cmd
  val part-counter : int ref
  val section-counter : int ref
  val subsection-counter : int ref
  val paragraph-counter : int ref
  
  direct \ref : [string] inline-cmd
  direct \ref-page : [string] inline-cmd
  direct \footnote : [inline-text] inline-cmd
  val footnote-counter : int ref
  val default-config-footnote : jlreq-footnote-config
  direct \figure : [string?; inline-text; block-text] inline-cmd
end = struct
  let default-config-document = (|
    two-side = false;
    paper-size = A4Paper;
    horizontal-layout = HorizontalAuto;
    vertical-layout = VerticalAuto;
    header-sep  = ZW(1.0);
    header-height = ZW(1.0);
    font-size = 10pt;
    line-gap = 7pt;
    cjk-font = CJKFont-preset-ipaex(1.0);
    latin-font = LatinFont-preset-lmodern(1.0);
    column = 1;
    column-gap = ZW(2.0);
  |)
  
  let paper-size-to-width-height ps = 
    match ps with 
      | A0Paper -> (841mm,1189mm)
      | A1Paper -> (594mm,841mm)
      | A2Paper -> (420mm,594mm)
      | A3Paper -> (297mm,420mm)
      | A4Paper -> (210mm,297mm)
      | A5Paper -> (148mm,210mm)
      | USLegal -> (8.5inch,14inch)
      | USLetter -> (8.5inch,11inch)
      | UserDefinedPaper(w,h) -> (w,h)
  
  let-mutable ref-autoreference-counter <- 0
  
  %. 相互参照系
  let output-cross-reference ctx l =
    let ref-txt = 
      match (get-cross-reference l) with
      | None -> {?}
      | Some(s) -> embed-string s
    in
    read-inline ctx ref-txt
  let-inline ctx \ref l = output-cross-reference ctx (l ^ `:num`)
  let-inline ctx \ref-page l = output-cross-reference ctx (l ^ `:page`)
  
  %. スペース
  let-inline ctx \hspace len = inline-skip (JLReqFont.to-length len)
  
  %. 基本版面保持
  let-mutable ref-kihonhanmen <- (|
  |)
  
  %. フロート
  let-mutable ref-float-boxes <- []
  let-mutable ref-no-float-pages <- []
  let float-margin = ZW(1.2)
  let float-scheme config counter ctx ?:label caption inner =
    let () = counter <- !counter + 1 in
    let () = match label with
      |None -> ()
      |Some(l) -> register-cross-reference (l ^ `:num`) (arabic !counter)
    in
    let caption-ctx = JLReqFont.select-font config#caption-font ctx in
    let label-ctx = JLReqFont.select-font config#caption-label-font caption-ctx in
    let b-caption =
      (read-inline label-ctx (config#caption-label-format !counter)) ++ 
      (inline-skip (JLReqFont.to-length config#caption-after-label-space)) ++
      (read-inline caption-ctx caption)
    in
    let bb-inner =
      let d (_, _) _ _ _ = [] in
      block-frame-breakable ctx (2pt, 2pt, 2pt, 2pt) (d, d, d, d) (fun ctx -> (
        (read-block ctx inner) +++
        (line-break true true ctx (inline-fil ++ b-caption ++ inline-fil))
      ))
    in
    let () = ref-autoreference-counter <- !ref-autoreference-counter + 1 in
    let curpage-label = `footnote-scheme-auto-reference:` ^ (arabic !ref-autoreference-counter) in
    let curpage = 
      match get-cross-reference curpage-label with
      | None -> None
      | Some(s) -> (JLReqLib.string-to-int s)
    in
    let hook pbinfo _ =
      let () = register-cross-reference curpage-label (arabic pbinfo#page-number) in
      match curpage with
      | None -> (ref-float-boxes <- (pbinfo#page-number + 1,bb-inner) :: !ref-float-boxes)
      | Some(_) -> ()
    in
    let () =
      match curpage with
      | None -> ()
      | Some(p) -> (ref-float-boxes <- (p,bb-inner) :: !ref-float-boxes)
    in
    hook-page-break hook
  
  let-mutable figure-counter <- 0
  let-inline ctx \figure = float-scheme (|
      caption-font = Sans(ZW(1.0));
      caption-label-font = Sans(ZW(1.0));
      caption-after-label-space = ZW(1.0);
      caption-label-format = (fun n -> embed-string (arabic n));
    |) figure-counter ctx

  
  %. 見出し
  let-mutable part-counter <- 0
  let-mutable section-counter <- 0
  let-mutable subsection-counter <- 0
  let-mutable paragraph-counter <- 0
  let part-level = -1
  let section-levek = 0
  let subsection-level = 1
  let paragraph-level = 2
  let default-config-part = (|
    level = -1;
    font = Sans(ZW(1.7));
    label-font = Current;
    subtitle-font = Sans(ZW(1.4));
    gyodori = GyodoriCenter(4.0);
    label-format = (fun n -> (`第` ^ (arabic n) ^ `部`));
    reference-label-format = (fun n -> arabic n);
    subtitle-format = (fun s -> {—#s;—});
    indent = Length(0pt);
    end-indent = Length(0pt);
    after-label-space = ZW(1.0);
    second-heading-text-indent = (false,ZW(1.0));
    subtitle-indent = SubTitleIndent(false,ZW(1.0));
    reset-counters = [];    
    mark-format = (fun cnt txt -> {#cnt;\hspace(ZW(1.0));#txt;});
    clear-mark-levels = [];
    add-to-toc = true;
  |)
  let-block ctx +part = JLReqHeading.block-heading-scheme default-config-part part-counter ctx
  let default-config-subsection = (|
    level = 1;
    font = Sans(ZW(1.2));
    label-font = Current;
    subtitle-font = Sans(ZW(1.0));
    gyodori = GyodoriCenter(2.0);
    label-format = (fun n -> (arabic !section-counter) ^ `.` ^ (arabic n));
    reference-label-format = (fun n -> (arabic !section-counter) ^ `.` ^ (arabic n));
    subtitle-format = (fun s -> {—#s;—});
    indent = Length(0pt);
    end-indent = Length(0pt);
    after-label-space = ZW(1.0);
    second-heading-text-indent = (false,ZW(1.0));
    subtitle-indent = SubTitleIndent(false,ZW(1.0));
    reset-counters = [paragraph-counter];
    mark-format = (fun cnt txt -> {#cnt;\hspace(ZW(1.0));#txt;});
    clear-mark-levels = [];
    add-to-toc = true;
  |)
  let-block ctx +subsection = JLReqHeading.block-heading-scheme default-config-subsection subsection-counter ctx
  let default-config-section = (|
    level = 0;
    font = Sans(ZW(1.4));
    label-font = Current;
    subtitle-font = Sans(ZW(1.0));
    gyodori = GyodoriCenter(3.0);
    label-format = arabic;
    reference-label-format = arabic;
    subtitle-format = (fun s -> {—#s;—});
    indent = Length(0pt);
    end-indent = Length(0pt);
    after-label-space = ZW(1.0);
    second-heading-text-indent = (false,ZW(1.0));
    subtitle-indent = SubTitleIndent(false,ZW(1.0));
    reset-counters = [subsection-counter; paragraph-counter];
    mark-format = (fun cnt txt -> {#cnt;\hspace(ZW(1.0));#txt;});
    clear-mark-levels = [default-config-subsection#level];
    add-to-toc = true;
  |)
  let-block ctx +section = JLReqHeading.block-heading-scheme default-config-section section-counter ctx
  let default-config-paragraph = (|
    level = 2;
    font = Sans(ZW(1.0));
    indent = Length(0pt);
    after-label-space = ZW(1.0);
    after-space = ZW(1.0);
    label-format = (fun cnt -> ((arabic !section-counter) ^ `.` ^ (arabic !subsection-counter) ^ `.` ^ (arabic cnt)));
    reference-label-format = (fun cnt -> (arabic !section-counter) ^ `.` ^ (arabic !subsection-counter) ^ `.` ^ (arabic cnt));
    mark-format = (fun cnt txt -> {#cnt;\hspace(ZW(1.0));#txt;});
    clear-mark-levels = [];
    reset-counters = [];
    add-to-toc = true;
  |)
  let-block ctx +paragraph = JLReqHeading.run-in-heading-scheme default-config-paragraph paragraph-counter ctx


  let-mutable footnote-counter <- 0
  let default-config-footnote = (|
    reference-mark-type = Inline;
    reference-mark-font = Roman(ZW(0.6));
    font = Roman(ZW(0.8));
    line-gap = ZW(0.675);
    reference-mark-format = (fun n -> (arabic n) ^ `)`);
    indent = Length(0pt);
    second-indent = ZW(1.0);
  |)
  let-inline ctx \footnote = JLReqFootnote.footnote-scheme default-config-footnote footnote-counter ctx
  
  %. 段落
  let-block ctx +p inner =
    let font-size = get-font-size ctx in
    let paragraph = (inline-skip font-size) ++ (read-inline ctx inner) ++ inline-fil in
    line-break true true ctx paragraph

  let-block ctx +pn inner =
    let paragraph = (read-inline ctx inner) ++ inline-fil in
    line-break true true ctx paragraph
  
  %. maketitle
  let maketitle ctx title author date =
    let get-b font txt =
      let ib = read-inline (JLReqFont.select-font font ctx) txt in
      let (len,_,_) = get-natural-metrics ib in
      if len >' 0pt then
        line-break false false ctx (inline-fil ++ ib ++ inline-fil)
      else
        block-nil
    in
    let title-b = get-b (Roman(ZW(1.7))) title in
    let author-b = get-b (Roman(ZW(1.3))) author in
    let date-b = get-b (Roman(ZW(1.3))) date in
    let font-size = get-font-size ctx in
    let skip box length =
      if (get-natural-length box) >' 0pt then
        block-skip length
      else
        block-nil
    in
    title-b +++ (skip title-b (font-size *' 1.5)) +++ author-b +++ (skip author-b (font-size *' 1.5)) +++ date-b +++ (skip date-b (font-size *' 1.5))
  
  let toc ctx tocs = 
    let font-size = get-font-size ctx in
    block-skip font-size +++ 
    line-break false false ctx (read-inline (JLReqFont.select-font (Sans(ZW(1.4))) ctx) {目次} ++ inline-fil)  +++
    block-skip font-size +++ 
    tocs +++
    block-skip (font-size *' 1.7)


  let default-format = (|
    maketitle = maketitle;
    table-of-contents = toc;
  |)
  
  %. document
  let document record ?:configopt ?:formatopt ?:frontmatter inner =
    let config = Option.from default-config-document configopt in
    let formats = Option.from default-format formatopt in
    % check column
    let () = 
      if (config#column <> 1) && (config#column <> 2) then
        abort-with-message `Only column = 1 or column = 2 is supported`
      else
        ()
    in
    % フォント設定
    let cjkfont = 
      match config#cjk-font with
      | CJKFont-preset-ipaex(scale) -> (|
          mincho = (`ipaexm`, scale, 0.0);
          gothic = (`ipaexg`, scale, 0.0);
        |)
      | CJKFont(f) -> f
    in
    let latinfont = 
      match config#latin-font with
      | LatinFont-preset-lmodern(scale) -> (|
          roman = (`lmroman`, scale, 0.0);
          italic = (`lmroman-it`, scale, 0.0);
          sans = (`lmroman-b`, scale, 0.0);
        |)
      | LatinFont(f) -> f
    in
    let () = JLReqFont.register-font config#font-size config#line-gap (|
      cjk = cjkfont;
      latin = latinfont;
    |)
    in
    let get-standard-context width = 
      get-initial-context width (command \math) 
        |> set-dominant-wide-script Kana
        |> set-language Kana Japanese
        |> set-language HanIdeographic Japanese
        |> set-dominant-narrow-script Latin
        |> set-language Latin English
        |> set-font Kana cjkfont#mincho
        |> set-font HanIdeographic cjkfont#mincho
        |> set-font Latin latinfont#roman
        |> set-math-font `lmodern`
        |> set-hyphen-penalty 100
        |> set-min-gap-of-lines 0pt
    in


    let (paper-width,paper-height) = paper-size-to-width-height config#paper-size in
    let column-gap = JLReqFont.to-length config#column-gap in
    let (odd-left-margin,odd-right-margin) = 
      match config#horizontal-layout with 
      | HorizontalAuto -> 
        let tw = paper-width *' 0.75 in
        let twmod = config#font-size *' (float (round (tw /' config#font-size))) in
        ((paper-width -' twmod) *' 0.5,(paper-width -' twmod) *' 0.5)
      | HorizontalCenter(n) -> 
        let len = JLReqFont.to-length n in
        let m = (paper-width -' len) *' 0.5 in
        (m,m)
      | Gutter(gd) -> 
        let len = ((JLReqFont.to-length gd#line-length) *' (float config#column)) +'  (column-gap *' (float (config#column - 1))) in
        let gutter = JLReqFont.to-length gd#gutter in
        (gutter,paper-width -' len -' gutter)
      | GutterFore-edge(gfe) ->
        let gutter = JLReqFont.to-length gfe#gutter in
        let fore-edge = JLReqFont.to-length gfe#fore-edge in
        (gutter,fore-edge)
    in
    % 1.0ptはおまじない……
    let text-width = (paper-width -' odd-left-margin -' odd-right-margin +' 1.0pt -' (column-gap *' (float (config#column - 1)))) *' (1.0 /. (float config#column)) in
    let (top-space,bottom-space) = 
      match config#vertical-layout with
      | VerticalAuto -> (paper-height *' 0.125,paper-height *' 0.125)
      | VerticalCenter(n) ->
        let len = JLReqFont.to-length n in
        let s= (paper-height -' len) *' 0.5 in
        (s,s)
      | Top(td) ->
        let top-space = JLReqFont.to-length td#top-space in
        let len = JLReqFont.to-length td#block-length in
        (top-space,paper-height -' len -' top-space)
      | TopBottom(tbd)->
        let top-space = JLReqFont.to-length tbd#top-space in
        let bottom-space = JLReqFont.to-length tbd#bottom-space in
        (top-space,bottom-space)
    in
    let get-left-margin pagenum =
      if config#two-side && (pagenum mod 2 == 0) then
        odd-right-margin
      else
        odd-left-margin
    in
    let max-float-height = (paper-height -' top-space -' bottom-space) *' 0.5 in
    let is-no-float-page pbinfo =
      List.fold-left (fun b p -> (if p == pbinfo#page-number then true else b)) false !ref-no-float-pages
    in
    let height-of-float-boxes pbinfo =
      if is-no-float-page pbinfo then (0pt,0)
      else
        (!ref-float-boxes) |> List.fold-left (fun (h,n) (pn, bb) -> (
          if pn > pbinfo#page-number then (h,n)
          else
            let hh = h +' (get-natural-length bb) +' (JLReqFont.to-length float-margin) in
            if hh <' max-float-height || n == 0 then (hh,n + 1)
            else (h,n)
        )) (0pt,0)
    in
    let () = if record#show-title then ref-no-float-pages <- 1 :: !ref-no-float-pages else () in
    let page-layout pbinfo =
      let (hofb,_) = height-of-float-boxes pbinfo in
      let xpoint = get-left-margin (JLReqPageNumber.get-page-number pbinfo) in
      (|
        text-origin = (xpoint,top-space +' hofb);
        text-height = paper-height -' top-space -' bottom-space -' hofb;
      |)
    in
    let head-height = JLReqFont.to-length config#header-height in
    let head-sep = JLReqFont.to-length config#header-sep in
    let () = ref-kihonhanmen <- (|
    |) in
    let pagestyle pbinfo = 
      let ctx = get-standard-context text-width in
      let (h,f) = 
        if config#two-side && ((JLReqPageNumber.get-page-number pbinfo) mod 2 == 0) then 
          (JLReqPageStyle.even-header,JLReqPageStyle.even-footer)
        else
          (JLReqPageStyle.odd-header,JLReqPageStyle.odd-footer)
      in
      let hc = h ctx pbinfo (JLReqPageNumber.get-page-number-str pbinfo) in
      let fc = f ctx pbinfo (JLReqPageNumber.get-page-number-str pbinfo) in
      let xpoint = get-left-margin (JLReqPageNumber.get-page-number pbinfo) in
      % フロートボックスの構築
      let (_,number-of-float-boxes) = height-of-float-boxes pbinfo in
      let (output-float-boxes,rest-float,_) = 
        if is-no-float-page pbinfo then (block-nil,!ref-float-boxes,0)
        else
        List.fold-right (fun (page,box) (o,r,n) -> (
          if (n >= number-of-float-boxes || page > pbinfo#page-number) then (o,(page,box) :: r,n)
          else
            let b = line-break true true (set-paragraph-margin 0pt (JLReqFont.to-length float-margin) ctx)
              (inline-fil ++ (embed-block-top ctx text-width (fun _ -> box) ++ inline-fil))
            in
            (o +++ b,r,n + 1)
        )) (block-nil,[],0) !ref-float-boxes
      in
      let () = ref-float-boxes <- rest-float in
      (|
        header-content = hc +++ output-float-boxes;
        header-origin = (xpoint,top-space -' head-sep -' head-height);
        footer-content = fc;
        footer-origin = (xpoint,paper-height -' bottom-space +' head-sep);
      |)
    in
    let ctx-doc = get-standard-context text-width
      |> set-font-size config#font-size
      |> set-leading (config#font-size +' config#line-gap)
      |> set-paragraph-margin config#line-gap config#line-gap
    in
    let main-block = read-block ctx-doc inner in
    let title-b = 
      if record#show-title then formats#maketitle ctx-doc record#title record#author record#date
      else block-nil
    in
    let frontmatter-b =
      match frontmatter with
      | None -> block-nil
      | Some(f) -> read-block ctx-doc f
    in
    let toc-b = 
      if record#show-toc then 
        formats#table-of-contents ctx-doc (JLReqTOC.table-of-contents ctx-doc [])
      else
        block-nil
    in
    let doc = 
      if config#column == 1 then
        page-break config#paper-size page-layout pagestyle (title-b +++ frontmatter-b +++ toc-b +++ main-block)
      else
        page-break-two-column config#paper-size (text-width +' column-gap) (fun () -> block-nil) page-layout pagestyle (title-b +++ frontmatter-b +++ toc-b +++ main-block) 
    in
    doc

end

let document = JLReq.document

